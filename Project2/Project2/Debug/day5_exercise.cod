; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30139.0 

	TITLE	D:\class\Project2\Project2\Debug\day5_exercise.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__9B4E3B6E_day5_exercise@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BB@KDIEHJFC@?$CFp?0?5?$CFp?0?5?$CFd?0?5?$CFd?6?6@ ; `string'
PUBLIC	??_C@_07ELHAAAOE@?$CFf?0?5?$CFp?6@		; `string'
PUBLIC	__real@40243851eb851eb8
PUBLIC	__real@4059070a3d70a3d7
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__calloc:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __real@4059070a3d70a3d7
CONST	SEGMENT
__real@4059070a3d70a3d7 DQ 04059070a3d70a3d7r	; 100.11
CONST	ENDS
;	COMDAT __real@40243851eb851eb8
CONST	SEGMENT
__real@40243851eb851eb8 DQ 040243851eb851eb8r	; 10.11
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_07ELHAAAOE@?$CFf?0?5?$CFp?6@
CONST	SEGMENT
??_C@_07ELHAAAOE@?$CFf?0?5?$CFp?6@ DB '%f, %p', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KDIEHJFC@?$CFp?0?5?$CFp?0?5?$CFd?0?5?$CFd?6?6@
CONST	SEGMENT
??_C@_0BB@KDIEHJFC@?$CFp?0?5?$CFp?0?5?$CFd?0?5?$CFd?6?6@ DB '%p, %p, %d, '
	DB	'%d', 0aH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	01e9H
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\class\Project2\Project2\day5_exercise.c
;	COMDAT _main
_TEXT	SEGMENT
_r$1 = -492						; size = 4
_ppDoubleArray$ = -480					; size = 4
_dbArray$ = -468					; size = 400
_p$ = -60						; size = 4
_a$ = -48						; size = 40
__$ArrayPad$ = -4					; size = 4
_main	PROC						; COMDAT

; 4    : int main() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b0 02 00
	00		 sub	 esp, 688		; 000002b0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 10 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-496]
  00012	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __9B4E3B6E_day5_exercise@c
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5    :     int a[10] = { 0 }; // stack -int 10개만큼 메모리를 할당

  00032	33 c0		 xor	 eax, eax
  00034	89 45 d0	 mov	 DWORD PTR _a$[ebp], eax
  00037	89 45 d4	 mov	 DWORD PTR _a$[ebp+4], eax
  0003a	89 45 d8	 mov	 DWORD PTR _a$[ebp+8], eax
  0003d	89 45 dc	 mov	 DWORD PTR _a$[ebp+12], eax
  00040	89 45 e0	 mov	 DWORD PTR _a$[ebp+16], eax
  00043	89 45 e4	 mov	 DWORD PTR _a$[ebp+20], eax
  00046	89 45 e8	 mov	 DWORD PTR _a$[ebp+24], eax
  00049	89 45 ec	 mov	 DWORD PTR _a$[ebp+28], eax
  0004c	89 45 f0	 mov	 DWORD PTR _a$[ebp+32], eax
  0004f	89 45 f4	 mov	 DWORD PTR _a$[ebp+36], eax

; 6    :     int(*p)[10] = &a; // stack - * (4bytes) - 해석단위 int[10]

  00052	8d 45 d0	 lea	 eax, DWORD PTR _a$[ebp]
  00055	89 45 c4	 mov	 DWORD PTR _p$[ebp], eax

; 7    :     printf("%p, %p, %d, %d\n\n", a, &a, sizeof(&a), sizeof(a));

  00058	6a 28		 push	 40			; 00000028H
  0005a	6a 04		 push	 4
  0005c	8d 45 d0	 lea	 eax, DWORD PTR _a$[ebp]
  0005f	50		 push	 eax
  00060	8d 4d d0	 lea	 ecx, DWORD PTR _a$[ebp]
  00063	51		 push	 ecx
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KDIEHJFC@?$CFp?0?5?$CFp?0?5?$CFd?0?5?$CFd?6?6@
  00069	e8 00 00 00 00	 call	 _printf
  0006e	83 c4 14	 add	 esp, 20			; 00000014H

; 8    :     double dbArray[5][10] = { 0 }; // stack - double 5*10 크기만큼 연속적으로 메모리에 할당(400bytes)

  00071	68 90 01 00 00	 push	 400			; 00000190H
  00076	6a 00		 push	 0
  00078	8d 85 2c fe ff
	ff		 lea	 eax, DWORD PTR _dbArray$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 _memset
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH

; 9    :     //시작위치 주소 + 변위 접근 [2][1] + 20 + 1
; 10   :     dbArray[2][1] = 10.11;

  00087	b8 50 00 00 00	 mov	 eax, 80			; 00000050H
  0008c	d1 e0		 shl	 eax, 1
  0008e	8d 8c 05 2c fe
	ff ff		 lea	 ecx, DWORD PTR _dbArray$[ebp+eax]
  00095	ba 08 00 00 00	 mov	 edx, 8
  0009a	c1 e2 00	 shl	 edx, 0
  0009d	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@40243851eb851eb8
  000a5	f2 0f 11 04 11	 movsd	 QWORD PTR [ecx+edx], xmm0

; 11   :     double** ppDoubleArray;//stack -주소값 크기만큼(32bit, 4bytes), double**, (double*), (double)
; 12   :     // * ppDouble Array => double*
; 13   :     // **ppDoubleArray => double
; 14   :     ppDoubleArray = (double**)calloc(5, sizeof(double*)); // heap - 주소값 크기만큼(32bit, 4bytes) * 5개, 할당

  000aa	8b f4		 mov	 esi, esp
  000ac	6a 04		 push	 4
  000ae	6a 05		 push	 5
  000b0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  000b6	83 c4 08	 add	 esp, 8
  000b9	3b f4		 cmp	 esi, esp
  000bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c0	89 85 20 fe ff
	ff		 mov	 DWORD PTR _ppDoubleArray$[ebp], eax

; 15   :     // pp DoubleArray -> double*의 시작주소
; 16   :     
; 17   :     for (int r = 0; r < 5; r++)

  000c6	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _r$1[ebp], 0
  000d0	eb 0f		 jmp	 SHORT $LN4@main
$LN2@main:
  000d2	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _r$1[ebp]
  000d8	83 c0 01	 add	 eax, 1
  000db	89 85 14 fe ff
	ff		 mov	 DWORD PTR _r$1[ebp], eax
$LN4@main:
  000e1	83 bd 14 fe ff
	ff 05		 cmp	 DWORD PTR _r$1[ebp], 5
  000e8	7d 27		 jge	 SHORT $LN3@main

; 18   :     {
; 19   :         //Double*(더블포인터형)에 double로 만든 메모리 시작주소값을 넣음
; 20   :         ppDoubleArray[r] = (double*)calloc(10, sizeof(double)); // heap - double 크기만큼 *10개 할당

  000ea	8b f4		 mov	 esi, esp
  000ec	6a 08		 push	 8
  000ee	6a 0a		 push	 10			; 0000000aH
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__calloc
  000f6	83 c4 08	 add	 esp, 8
  000f9	3b f4		 cmp	 esi, esp
  000fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00100	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _r$1[ebp]
  00106	8b 95 20 fe ff
	ff		 mov	 edx, DWORD PTR _ppDoubleArray$[ebp]
  0010c	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 21   :     } //총 5번의 루프를 돌면 50개의 메모리 할당을 하고 13행의 다섯개에 주소를 저장해줌

  0010f	eb c1		 jmp	 SHORT $LN2@main
$LN3@main:

; 22   :     ppDoubleArray[2][1] = 100.11;

  00111	b8 04 00 00 00	 mov	 eax, 4
  00116	d1 e0		 shl	 eax, 1
  00118	b9 08 00 00 00	 mov	 ecx, 8
  0011d	c1 e1 00	 shl	 ecx, 0
  00120	8b 95 20 fe ff
	ff		 mov	 edx, DWORD PTR _ppDoubleArray$[ebp]
  00126	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00129	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4059070a3d70a3d7
  00131	f2 0f 11 04 01	 movsd	 QWORD PTR [ecx+eax], xmm0

; 23   :     printf("%f, %p\n", (*(ppDoubleArray + 2))[1], &(*(ppDoubleArray + 2))[1]);

  00136	b8 08 00 00 00	 mov	 eax, 8
  0013b	c1 e0 00	 shl	 eax, 0
  0013e	8b 8d 20 fe ff
	ff		 mov	 ecx, DWORD PTR _ppDoubleArray$[ebp]
  00144	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00147	50		 push	 eax
  00148	ba 08 00 00 00	 mov	 edx, 8
  0014d	c1 e2 00	 shl	 edx, 0
  00150	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _ppDoubleArray$[ebp]
  00156	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00159	83 ec 08	 sub	 esp, 8
  0015c	f2 0f 10 04 11	 movsd	 xmm0, QWORD PTR [ecx+edx]
  00161	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00166	68 00 00 00 00	 push	 OFFSET ??_C@_07ELHAAAOE@?$CFf?0?5?$CFp?6@
  0016b	e8 00 00 00 00	 call	 _printf
  00170	83 c4 10	 add	 esp, 16			; 00000010H

; 24   :     printf("%f, %p\n", *((*(ppDoubleArray + 2)) + 1), &*((*(ppDoubleArray + 2)) + 1));

  00173	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _ppDoubleArray$[ebp]
  00179	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0017c	83 c1 08	 add	 ecx, 8
  0017f	51		 push	 ecx
  00180	8b 95 20 fe ff
	ff		 mov	 edx, DWORD PTR _ppDoubleArray$[ebp]
  00186	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00189	83 ec 08	 sub	 esp, 8
  0018c	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  00191	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_07ELHAAAOE@?$CFf?0?5?$CFp?6@
  0019b	e8 00 00 00 00	 call	 _printf
  001a0	83 c4 10	 add	 esp, 16			; 00000010H

; 25   :     printf("%f, %p\n", *((*(ppDoubleArray + 2)) + 1), (*(ppDoubleArray + 2)) + 1);

  001a3	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _ppDoubleArray$[ebp]
  001a9	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001ac	83 c1 08	 add	 ecx, 8
  001af	51		 push	 ecx
  001b0	8b 95 20 fe ff
	ff		 mov	 edx, DWORD PTR _ppDoubleArray$[ebp]
  001b6	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  001b9	83 ec 08	 sub	 esp, 8
  001bc	f2 0f 10 40 08	 movsd	 xmm0, QWORD PTR [eax+8]
  001c1	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001c6	68 00 00 00 00	 push	 OFFSET ??_C@_07ELHAAAOE@?$CFf?0?5?$CFp?6@
  001cb	e8 00 00 00 00	 call	 _printf
  001d0	83 c4 10	 add	 esp, 16			; 00000010H

; 26   : }

  001d3	33 c0		 xor	 eax, eax
  001d5	52		 push	 edx
  001d6	8b cd		 mov	 ecx, ebp
  001d8	50		 push	 eax
  001d9	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@main
  001df	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  001e4	58		 pop	 eax
  001e5	5a		 pop	 edx
  001e6	5f		 pop	 edi
  001e7	5e		 pop	 esi
  001e8	5b		 pop	 ebx
  001e9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ec	33 cd		 xor	 ecx, ebp
  001ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f3	81 c4 b0 02 00
	00		 add	 esp, 688		; 000002b0H
  001f9	3b ec		 cmp	 ebp, esp
  001fb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00200	8b e5		 mov	 esp, ebp
  00202	5d		 pop	 ebp
  00203	c3		 ret	 0
$LN9@main:
  00204	02 00 00 00	 DD	 2
  00208	00 00 00 00	 DD	 $LN8@main
$LN8@main:
  0020c	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00210	28 00 00 00	 DD	 40			; 00000028H
  00214	00 00 00 00	 DD	 $LN6@main
  00218	2c fe ff ff	 DD	 -468			; fffffe2cH
  0021c	90 01 00 00	 DD	 400			; 00000190H
  00220	00 00 00 00	 DD	 $LN7@main
$LN7@main:
  00224	64		 DB	 100			; 00000064H
  00225	62		 DB	 98			; 00000062H
  00226	41		 DB	 65			; 00000041H
  00227	72		 DB	 114			; 00000072H
  00228	72		 DB	 114			; 00000072H
  00229	61		 DB	 97			; 00000061H
  0022a	79		 DB	 121			; 00000079H
  0022b	00		 DB	 0
$LN6@main:
  0022c	61		 DB	 97			; 00000061H
  0022d	00		 DB	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  0000f	b9 06 00 00 00	 mov	 ecx, 6
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00025	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00028	89 45 ec	 mov	 DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0002b	8b 45 ec	 mov	 eax, DWORD PTR __ArgList$[ebp]
  0002e	50		 push	 eax
  0002f	6a 00		 push	 0
  00031	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00034	51		 push	 ecx
  00035	8b f4		 mov	 esi, esp
  00037	6a 01		 push	 1
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0003f	83 c4 04	 add	 esp, 4
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 __vfprintf_l
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

  00055	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 963  :     }

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00021	8b f4		 mov	 esi, esp
  00023	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00026	50		 push	 eax
  00027	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00038	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003b	51		 push	 ecx
  0003c	8b 10		 mov	 edx, DWORD PTR [eax]
  0003e	52		 push	 edx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00045	83 c4 18	 add	 esp, 24			; 00000018H
  00048	3b f4		 cmp	 esi, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __A2143F22_corecrt_stdio_config@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00021	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
