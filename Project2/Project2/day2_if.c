/*
#include <stdio.h> // <-전처리기이다. 전처리기한테 stdio.h 코드를 이 파일에 넣어줘 라는 뜻이다. 이걸 넣어야 printf, scanf 를 쓸수 있다.

// 프로그램의 시작점이고 운영체제가 우리으 ㅣ실행파일을 메모링 ㅔ로드 후 제일 처음 호출해주는 함수이다.(main 함수)
int main(void) {

	int score = 0; //변수, 식별자 score로 메모리의 일부 공간을 할당하는 코드이다. 변수 선언문이다.
	//int score; // 변수 초기화 코드가 없는 코드이다. 위는 변수를 선언하며 바로 초기화

	printf("당신의 점수를 입력해주세요 >> ");
	scanf_s("%d", &score); // <-score라는 변수를 선언하며 메로리 공간을 할당했고, 할당받은 공간의 주소값을 전달한다. &는 주소값 연산자이다. 주소를 보내는 것.
                         //scanf <- 사용자의 읿력을 받음.
	                     // _s score의 크기를 모르기 떄문에 배열이나 주소값 등은 길이를 모르기 떄문에 이것의 안전장치, secure의 약자로 _s를 붙인다 

	if (score) { //-> score의 값이 0이면 false 그 외는 true
		printf("ture");// 0이 아니라면 이 코드 실행
	}
	else if(score == 0 || score == 1){ // score가 0인지 먼저 체크, 그 이후 1인지 체크, 왼쪽부터 순차적으로 체크함.
		printf("0");
	}
	else {
		printf("false");
	}
	//사용자에게 70을 입력받는다.
	// 아래 코드 실행 후 score은 값이 어떻게 될까? 71로 나온다. 이유는 ++score의 뜻은 연산 이후 score처리하는 것이기 때문
	if (score == 70 && ++score == 71) {
	// if (score == 70 || ++score ==71) 이렇게 된다면 70를 받으면 score 은 70이다. 연산자 우선순위에 따라 움직인다!
		printf("score true");
	}
	else {
		printf("score false");
	}
	printf("%d", score);
	
	
	switch (score) {
	case 50+1: //런타임에 연산을 하는게 아니라 코드상에서 컴파일러가 순간적으로 계산한다.
		printf("50----");
		break;
	case 53:
		printf("53----");
		break;
	default :
		printf("default");
		break;
	}

	50 과 51이 똑같은 행위를 할떄
		case 50:
		case 51:
		printf("53----");
		break;
		이렇게 작성해도 된다.
	스위치문은 점프문 기반으로 동작한다. 테이블이 들어가고 점프문~
	if는 조건식을 작성
	switch는 조건값을 작성
	switch는 비교를 최소화해서 메모리값을 아낀다. if문은 최악경우 비교를 다 하므로 메모리값을 많이 잡아먹을 수 잇다.
	스위치문은 값에 대한 분기 그래서 case 에 값을 넣어줘야한다., 값에는 정수만 넣어줘야한다. 1.00같은건 안됨
	케이스 범위의 칸 마다 메모리를 차지한다. 50, 99케이스문을 하면 50개의 메모리가 필요함 1~49번쨰 메모리는 default 0번째는 50 50번쨰는 99에 해당함
	이프문은 조건식에 대한 분기
 	

	return 0; //호출자에게 어떤 값을 반환하는 코드
}
*/
//exit 반환값. return 이후에도 마무리하는 코드가 몇줄 실행된다. 프로세스 종료 등
// 어셈블리어 cmp = compare 
